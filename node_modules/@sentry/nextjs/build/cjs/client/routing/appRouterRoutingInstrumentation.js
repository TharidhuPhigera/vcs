Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const core = require('@sentry/core');
const react = require('@sentry/react');

const INCOMPLETE_APP_ROUTER_INSTRUMENTATION_TRANSACTION_NAME = 'incomplete-app-router-transaction';

/** Instruments the Next.js app router for pageloads. */
function appRouterInstrumentPageLoad(client) {
  const origin = core.browserPerformanceTimeOrigin();
  react.startBrowserTracingPageLoadSpan(client, {
    name: react.WINDOW.location.pathname,
    // pageload should always start at timeOrigin (and needs to be in s, not ms)
    startTime: origin ? origin / 1000 : undefined,
    attributes: {
      [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',
      [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.nextjs.app_router_instrumentation',
      [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
    },
  });
}

// Yes, yes, I know we shouldn't depend on these internals. But that's where we are at. We write the ugly code, so you don't have to.
const GLOBAL_OBJ_WITH_NEXT_ROUTER = core.GLOBAL_OBJ

;

/*
 * The routing instrumentation needs to handle a few cases:
 * - Router operations:
 *  - router.push() (either explicitly called or implicitly through <Link /> tags)
 *  - router.replace() (either explicitly called or implicitly through <Link replace /> tags)
 *  - router.back()
 *  - router.forward()
 * - Browser operations:
 *  - native Browser-back / popstate event (implicitly called by router.back())
 *  - native Browser-forward / popstate event (implicitly called by router.forward())
 */

/** Instruments the Next.js app router for navigation. */
function appRouterInstrumentNavigation(client) {
  const currentNavigationSpanRef = { current: undefined };

  react.WINDOW.addEventListener('popstate', () => {
    if (currentNavigationSpanRef.current?.isRecording()) {
      currentNavigationSpanRef.current.updateName(react.WINDOW.location.pathname);
      currentNavigationSpanRef.current.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'url');
    } else {
      currentNavigationSpanRef.current = react.startBrowserTracingNavigationSpan(client, {
        name: react.WINDOW.location.pathname,
        attributes: {
          [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',
          [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.nextjs.app_router_instrumentation',
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
          'navigation.type': 'browser.popstate',
        },
      });
    }
  });

  let routerPatched = false;
  let triesToFindRouter = 0;
  const MAX_TRIES_TO_FIND_ROUTER = 500;
  const ROUTER_AVAILABILITY_CHECK_INTERVAL_MS = 20;
  const checkForRouterAvailabilityInterval = setInterval(() => {
    triesToFindRouter++;
    const router = GLOBAL_OBJ_WITH_NEXT_ROUTER?.next?.router ?? GLOBAL_OBJ_WITH_NEXT_ROUTER?.nd?.router;

    if (routerPatched || triesToFindRouter > MAX_TRIES_TO_FIND_ROUTER) {
      clearInterval(checkForRouterAvailabilityInterval);
    } else if (router) {
      clearInterval(checkForRouterAvailabilityInterval);
      routerPatched = true;

      patchRouter(client, router, currentNavigationSpanRef);

      // If the router at any point gets overridden - patch again
      (['nd', 'next'] ).forEach(globalValueName => {
        const globalValue = GLOBAL_OBJ_WITH_NEXT_ROUTER[globalValueName];
        if (globalValue) {
          GLOBAL_OBJ_WITH_NEXT_ROUTER[globalValueName] = new Proxy(globalValue, {
            set(target, p, newValue) {
              if (p === 'router' && typeof newValue === 'object' && newValue !== null) {
                patchRouter(client, newValue, currentNavigationSpanRef);
              }

              // @ts-expect-error we cannot possibly type this
              target[p] = newValue;
              return true;
            },
          });
        }
      });
    }
  }, ROUTER_AVAILABILITY_CHECK_INTERVAL_MS);
}

function transactionNameifyRouterArgument(target) {
  try {
    // We provide an arbitrary base because we only care about the pathname and it makes URL parsing more resilient.
    return new URL(target, 'http://example.com/').pathname;
  } catch {
    return '/';
  }
}

const patchedRouters = new WeakSet();

function patchRouter(client, router, currentNavigationSpanRef) {
  if (patchedRouters.has(router)) {
    return;
  }
  patchedRouters.add(router);

  (['back', 'forward', 'push', 'replace'] ).forEach(routerFunctionName => {
    if (router?.[routerFunctionName]) {
      // @ts-expect-error Weird type error related to not knowing how to associate return values with the individual functions - we can just ignore
      router[routerFunctionName] = new Proxy(router[routerFunctionName], {
        apply(target, thisArg, argArray) {
          let transactionName = INCOMPLETE_APP_ROUTER_INSTRUMENTATION_TRANSACTION_NAME;
          const transactionAttributes = {
            [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',
            [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.nextjs.app_router_instrumentation',
            [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
          };

          if (routerFunctionName === 'push') {
            transactionName = transactionNameifyRouterArgument(argArray[0]);
            transactionAttributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'url';
            transactionAttributes['navigation.type'] = 'router.push';
          } else if (routerFunctionName === 'replace') {
            transactionName = transactionNameifyRouterArgument(argArray[0]);
            transactionAttributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'url';
            transactionAttributes['navigation.type'] = 'router.replace';
          } else if (routerFunctionName === 'back') {
            transactionAttributes['navigation.type'] = 'router.back';
          } else if (routerFunctionName === 'forward') {
            transactionAttributes['navigation.type'] = 'router.forward';
          }

          currentNavigationSpanRef.current = react.startBrowserTracingNavigationSpan(client, {
            name: transactionName,
            attributes: transactionAttributes,
          });

          return target.apply(thisArg, argArray);
        },
      });
    }
  });
}

exports.INCOMPLETE_APP_ROUTER_INSTRUMENTATION_TRANSACTION_NAME = INCOMPLETE_APP_ROUTER_INSTRUMENTATION_TRANSACTION_NAME;
exports.appRouterInstrumentNavigation = appRouterInstrumentNavigation;
exports.appRouterInstrumentPageLoad = appRouterInstrumentPageLoad;
//# sourceMappingURL=appRouterRoutingInstrumentation.js.map
